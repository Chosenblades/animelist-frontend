import { error } from '@sveltejs/kit';
import { PUBLIC_API_URL } from '$env/static/public';

const relationSortOrder = [
	'Prequel',
	'Sequel',
	'Parent story',
	'Full story',
	'Side story',
	'Alternative version',
	'Alternative setting',
	'Summary',
	'Spin-off',
	'Other'
];

/** @type {import('./$types').PageLoad} */
export async function load({ fetch, params, setHeaders }) {
	const res = await fetch(`${PUBLIC_API_URL}/anime/${params.id}`);

	if (res.status !== 200) {
		console.log(res.status);
		throw error(404, 'Not found');
	}

	const anime = await res.json();
	return {
		anime: anime,
		streamed: {
			demographic: fetchDemographic(params.id, fetch),
			genres: fetchGenres(params.id, fetch),
			producers: fetchProducers(params.id, fetch),
			licensors: fetchLicensors(params.id, fetch),
			studios: fetchStudios(params.id, fetch),
			themes: fetchThemes(params.id, fetch),
			relations: fetchAnimeRelations(params.id, fetch),
			characters: fetchAnimeCharacters(params.id, fetch),
			staff: fetchAnimeStaff(params.id, fetch)
		}
	};
}

//I separated the queries because one giant query with nasty joins generated by sequelize was taking >10 seconds
//Instead of using sequelize's separate: true, I can take advantage of SvelteKit's new streamed option
//by separating the queries myself
//Page generally renders in under 500ms now

async function fetchDemographic(animeId, fetch) {
	const res = await fetch(`${PUBLIC_API_URL}/demographic/anime/${animeId}`);
	const demographic = await res.json();
	return demographic;
}

async function fetchGenres(animeId, fetch) {
	const res = await fetch(`${PUBLIC_API_URL}/genre/anime/${animeId}`);
	const genre = await res.json();
	return genre;
}

async function fetchProducers(animeId, fetch) {
	const res = await fetch(`${PUBLIC_API_URL}/producer/anime/${animeId}`);
	const producer = await res.json();
	return producer;
}

async function fetchLicensors(animeId, fetch) {
	const res = await fetch(`${PUBLIC_API_URL}/licensor/anime/${animeId}`);
	const licensor = await res.json();
	return licensor;
}

async function fetchStudios(animeId, fetch) {
	const res = await fetch(`${PUBLIC_API_URL}/studio/anime/${animeId}`);
	const studio = await res.json();
	return studio;
}

async function fetchThemes(animeId, fetch) {
	const res = await fetch(`${PUBLIC_API_URL}/theme/anime/${animeId}`);
	const theme = await res.json();
	return theme;
}

async function fetchAnimeRelations(animeId, fetch) {
	const res = await fetch(`${PUBLIC_API_URL}/anime/relations/${animeId}`);
	const relations = await res.json();
	if (relations) {
		relations.ChildAnime.sort(function (a, b) {
			return (
				relationSortOrder.indexOf(a.AnimeRelations.relation) -
				relationSortOrder.indexOf(b.AnimeRelations.relation)
			);
		});
	}
	return relations;
}

async function fetchAnimeCharacters(animeId, fetch) {
	const res = await fetch(`${PUBLIC_API_URL}/anime/${animeId}/characters`);
	const characters = await res.json();
	return characters;
}

async function fetchAnimeStaff(animeId, fetch) {
	const res = await fetch(`${PUBLIC_API_URL}/anime/${animeId}/staff`);
	const staff = await res.json();
	return staff;
}
